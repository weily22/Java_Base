# Java编程基础 Ⅱ



**JVM** 常量池[^1]保证相同的字符串直接量只有一个，不会产生多个副本，使用 new String() 创建的字符串对象是运行时创建出来的，它被保存在运行时内存区（即堆内存）内，不会放入常量池中。

[^1]: 专门用于管理在编译时被确定并保存在已编译的 .class 文件中的一些数据。它包括了关于类、接口中的常量，还包括字符串常量

**equals()** 是 Object 类提供的一个实例方法，使用这个方法判断两个对象相等的标准与使用 **==** 运算符没有区别，同样要求两个引用变量指向同一个对象才会返回 true。

**String **已经重写了Object 的 equals() 方法，String 的 equals() 方法判断两个字符串相等的标准是：只要两个字符串包含的字符序列相同，通过 equals() 比较将返回 true ，否则将返回 false。

重写 equals 方法：

```java
public boolean equals(Object obj) {
    // 如果两个对象为同一个对象
    if (this == obj) return true;
    ...
    return false
}
```

**static** 关键字修饰的成员就是 类成员[^2]

[^2]: 类成员有类变量、类方法、静态初始化块 

在 java 类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员

static 可以修饰成员变量、方法、初始化块、内部类（包括接口、枚举）

**类变量** ：属于整个类，当系统第一次准备使用该类时，系统会为该类变量分配内存空间，类变量开始生效，直到该类被卸载。

**类方法**：属于整个类，通常直接使用类作为调用者来调用类方法

**静态初始化块**：用于执行类初始化动作，在类的初始化阶段，系统会调用该类的初始化块来对类进行初始化。一旦初始化结束后，静态初始化块将永远不会获得执行的机会。

==

==

**===========================单例类========================**

如果一个类始终只能创建一个实例，则这个类被称为单例类。

为了避免其他类自由创建该类的实例，应该把该类的构造器使用 **private** 修饰，从而把该类的所有构造器隐藏起来。

提供一个 public 方法作为该类的访问点，用于创建该类的实例，且该方法必须使用 static 修饰（因为调用该方法之前还不存在对象，因此调用该方法的不可能是对象，只能是类）

除此之外，该类还必须缓存已经创建的对象，否则该类无法知道是否曾经创建过对象，也就无法保证只创建一个对象。为此该类需要使用一个成员变量来保存曾经创建的对象，因为该成员变量需要被上面的静态方法访问，故该成员变量必须使用 static 修饰。

```java
/**
*  单例类示例：
*/
class Singleton {
  // 使用一个类变量来缓存曾经创建的实例
  private static Singleton instance;
  // 对构造器使用 private 修饰，隐藏该构造器
  private Singleton () {}
  // 提供一个静态方法，用于返回 Singleton 实例
  // 
  public static Singleton getInstance() {
    // 如果 instance 为 null，则表明还不曾创建 Singleton 对象
    // 如果 instance 不为 null，则表明已经创建了 Singleton 对象
    // 将不会重新创建新的实例
    if (instance == null) {
      // 创建一个 Singleton 对象，并将其缓存起来
      instance = new Singleton();
    }
    return instance;
  }
}
public class SingletonTest {
  public static void main (String[] args) {
    // 创建 Singleton 对象不能通过构造器
    // 只能通过 getInstance 方法来得到实例
    Singleton s1 = Singleton.getInstance();
    Singleton s2 = Singleton.getInstance();
    System.out.println(s1 == s2);
  }
}

==>
true
```



**final** 关键字可用于修饰类、变量和方法

1. final 修饰变量时，表示该变量一旦获得了初始值就不可被改变。
2. final 既可以修饰成员变量（包括类变量和实例变量），也可以修饰局部变量、形参。

类初始化时，系统为该类的`类变量`分配内存，并分配默认值；当创建对象时，系统为该对象的`实例变量`分配内存，并分配默认值。

也就是说，当执行静态初始化时，可以对类变量赋初始值；当执行普通初始化块、构造器时可对实例赋初始值

3. 对于 final 修饰的成员变量而言，一旦有了初始值，就不能被重新赋值。
4. Java 语法规定：final 修饰的成员变量必须由程序员显示地指定初始值。

归纳：final 修饰的类变量、实例变量能指定初始值的地方：

* 类变量：必须在静态初始化块中或声明该类变量时指定初始值，且只能在两个地方的其中之一指定
* 实例变量：必须在非静态初始化块、声明该实例变量或构造器中指定初始值，且只能选一处指定。

5. final 修饰局部变量时，既可以在定义时指定默认值，也可以不指定默认值
6. final 修饰基本类型变量时，不能对基本类型变量赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用，final 只保证这个引用类型变量所引用的地址不会改变

对一个 final 变量来说，不管它是类变量、实例变量，只要该变量满足三个条件，这个 final 变量就不再是一个变量，而是相当于一个直接量。

* 使用 final 修饰符修饰
* 在定义该 final 变量时指定了初始值
* 该初始值可以在编译时就被确定下来

final 修饰符的一个重要用途就是定义"宏变量"。当定于 final 变量时就为该变量指定了初始值，而且该初始值可以在编译时就确定下来，那么这个 final 变量本质上就是一个 "宏变量"，编译器会把程序中所有用到该变量的地方直接替换成该变量的值。

如果被赋的表达式只是基本的算术表达式或字符串连接运算，没有访问普通变量，调用方法，Java 编译器同样会将这种 final 变量当成 "宏变量"处理。

Java 提供的 object 类里就有一个 final 方法：getClass()

7. final 修饰的方法不能被重写
8. final 修饰的类不可以有子类，例如 java.lang.Math类就是一个final类，它不可以有子类

==

==

**===========================不可变类**========================**

不可变（immutable）类的意思是创建该类的实例后，该实例变量是不可改变的。

Java 提供的8个包装类和 java.lang.String 都是不可变类

缓存实例的不可变类

