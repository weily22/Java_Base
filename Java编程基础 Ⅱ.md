# Java编程基础 Ⅱ



**JVM** 常量池[^1]保证相同的字符串直接量只有一个，不会产生多个副本，使用 new String() 创建的字符串对象是运行时创建出来的，它被保存在运行时内存区（即堆内存）内，不会放入常量池中。

[^1]: 专门用于管理在编译时被确定并保存在已编译的 .class 文件中的一些数据。它包括了关于类、接口中的常量，还包括字符串常量

**equals()** 是 Object 类提供的一个实例方法，使用这个方法判断两个对象相等的标准与使用 **==** 运算符没有区别，同样要求两个引用变量指向同一个对象才会返回 true。

**String **已经重写了Object 的 equals() 方法，String 的 equals() 方法判断两个字符串相等的标准是：只要两个字符串包含的字符序列相同，通过 equals() 比较将返回 true ，否则将返回 false。

重写 equals 方法：

```java
public boolean equals(Object obj) {
    // 如果两个对象为同一个对象
    if (this == obj) return true;
    ...
    return false
}
```

**static** 关键字修饰的成员就是 类成员[^2]

[^2]: 类成员有类变量、类方法、静态初始化块 

在 java 类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员

static 可以修饰成员变量、方法、初始化块、内部类（包括接口、枚举）

**类变量** ：属于整个类，当系统第一次准备使用该类时，系统会为该类变量分配内存空间，类变量开始生效，直到该类被卸载。

**类方法**：属于整个类，通常直接使用类作为调用者来调用类方法

**静态初始化块**：用于执行类初始化动作，在类的初始化阶段，系统会调用该类的初始化块来对类进行初始化。一旦初始化结束后，静态初始化块将永远不会获得执行的机会。

==

==

**===========================单例类========================**

如果一个类始终只能创建一个实例，则这个类被称为单例类。

为了避免其他类自由创建该类的实例，应该把该类的构造器使用 **private** 修饰，从而把该类的所有构造器隐藏起来。

提供一个 public 方法作为该类的访问点，用于创建该类的实例，且该方法必须使用 static 修饰（因为调用该方法之前还不存在对象，因此调用该方法的不可能是对象，只能是类）

除此之外，该类还必须缓存已经创建的对象，否则该类无法知道是否曾经创建过对象，也就无法保证只创建一个对象。为此该类需要使用一个成员变量来保存曾经创建的对象，因为该成员变量需要被上面的静态方法访问，故该成员变量必须使用 static 修饰。

```java
/**
*  单例类示例：
*/
class Singleton {
  // 使用一个类变量来缓存曾经创建的实例
  private static Singleton instance;
  // 对构造器使用 private 修饰，隐藏该构造器
  private Singleton () {}
  // 提供一个静态方法，用于返回 Singleton 实例
  // 
  public static Singleton getInstance() {
    // 如果 instance 为 null，则表明还不曾创建 Singleton 对象
    // 如果 instance 不为 null，则表明已经创建了 Singleton 对象
    // 将不会重新创建新的实例
    if (instance == null) {
      // 创建一个 Singleton 对象，并将其缓存起来
      instance = new Singleton();
    }
    return instance;
  }
}
public class SingletonTest {
  public static void main (String[] args) {
    // 创建 Singleton 对象不能通过构造器
    // 只能通过 getInstance 方法来得到实例
    Singleton s1 = Singleton.getInstance();
    Singleton s2 = Singleton.getInstance();
    System.out.println(s1 == s2);
  }
}

==>
true
```



**final** 关键字可用于修饰类、变量和方法

1. final 修饰变量时，表示该变量一旦获得了初始值就不可被改变。
2. final 既可以修饰成员变量（包括类变量和实例变量），也可以修饰局部变量、形参。

类初始化时，系统为该类的`类变量`分配内存，并分配默认值；当创建对象时，系统为该对象的`实例变量`分配内存，并分配默认值。

也就是说，当执行静态初始化时，可以对类变量赋初始值；当执行普通初始化块、构造器时可对实例赋初始值

3. 对于 final 修饰的成员变量而言，一旦有了初始值，就不能被重新赋值。
4. Java 语法规定：final 修饰的成员变量必须由程序员显示地指定初始值。

归纳：final 修饰的类变量、实例变量能指定初始值的地方：

* 类变量：必须在静态初始化块中或声明该类变量时指定初始值，且只能在两个地方的其中之一指定
* 实例变量：必须在非静态初始化块、声明该实例变量或构造器中指定初始值，且只能选一处指定。

5. final 修饰局部变量时，既可以在定义时指定默认值，也可以不指定默认值
6. final 修饰基本类型变量时，不能对基本类型变量赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用，final 只保证这个引用类型变量所引用的地址不会改变

对一个 final 变量来说，不管它是类变量、实例变量，只要该变量满足三个条件，这个 final 变量就不再是一个变量，而是相当于一个直接量。

* 使用 final 修饰符修饰
* 在定义该 final 变量时指定了初始值
* 该初始值可以在编译时就被确定下来

final 修饰符的一个重要用途就是定义"宏变量"。当定于 final 变量时就为该变量指定了初始值，而且该初始值可以在编译时就确定下来，那么这个 final 变量本质上就是一个 "宏变量"，编译器会把程序中所有用到该变量的地方直接替换成该变量的值。

如果被赋的表达式只是基本的算术表达式或字符串连接运算，没有访问普通变量，调用方法，Java 编译器同样会将这种 final 变量当成 "宏变量"处理。

Java 提供的 object 类里就有一个 final 方法：getClass()

7. final 修饰的方法不能被重写
8. final 修饰的类不可以有子类，例如 java.lang.Math类就是一个final类，它不可以有子类

==

==

**===========================不可变类**========================**

不可变（immutable）类的意思是创建该类的实例后，该实例变量是不可改变的。

Java 提供的8个包装类和 java.lang.String 都是不可变类

缓存实例的不可变类



=========================抽象类=====================

* 抽象类和抽象方法使用 ***abstract*** 修饰符来修饰

* 当使用 abstract 修饰 **类** 时，表明这个类只能被继承

* 当使用 abstract 修饰 **方法** 时，表明这个方法必须由子类提供实现（重写）

* 抽象类不能被实例化

* 抽象类的构造器不能用于创建实例，主要用于被其子类调用

* 抽象类里的初始化块和构造器是在创建其子类的实例时被调用

* 抽象方法没有方法体

* 含有抽象方法的类

  1. 直接定义了一个抽象方法
  2. 继承了一个抽象父类，但没有完全实现父类包含的抽象方法
  3. 实现了一个接口，但没有完全实现接口包含的抽象方法

  只能被定义成抽象类

**抽象类的作用：**

* 体现的是一种模板模式的设计，抽象类作为多个子类的通用模板，并把一个或多个方法留给其子类实现

* 抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，留给其子类去实现。

**Java 8 改进的接口**

接口，特殊的抽象类，接口里不能包含普通方法，接口里的所有方法都是抽象方法。Java 8 对接口进行了改进，允许在接口定义中定义默认方法，默认方法可以提供方法实现。

定义接口 ，使用 **interface** 关键字。接口定义的基本语法：

```java
[修饰符] interface 接口名 extends 父接口1, 父接口2...
{
    零个到多个常量定义...
    零个到多个抽象方法定义...
    零个到多个内部类、接口、枚举定义...
    零个到多个默认方法或类方法定义...
}

// 修饰符: 可以是 public 或者省略，如果省略了public访问控制符，则默认采用包权限访问控制符，即只有在相同包结构下才可以访问该接口
// 接口名：同类名命名规则
// 一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类
```

接口：

1. 不能包含构造器和初始化块定义
2. 可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法或默认方法）
3. 接口里定义的是多个类共同的公共行为规范，因此接口里的所有成员，包括常量、方法、内部类和内部枚举都是 public 访问权限
4. 接口里定义的静态常量，他们是接口相关的，因此系统会自动为这些成员变量增加 static 和 final 两个修饰符。
5. 接口里定义的 内部类、内部接口、内部枚举默认都采用 public static 两个修饰符

接口完全支持多继承，即一个接口可以有多个直接父接口。子接口扩展某个父接口时，多个父接口排在 extends 关键字之后，多个父接口之间以英文逗号（,）隔开。

```java
interface interfaceA {
  int PROP_A = 5;
  void testA();
}

interface interfaceB {
  int PROP_B = 6;
  void testB();
}

interface interfaceC extends interfaceA, interfaceB {
  int PROP_C = 7;
  void testC();
}

public class InterfaceExtendsTest{
  public static void main(String[] args) {
    System.out.println(interfaceC.PROP_A);
    System.out.println(interfaceC.PROP_B);
    System.out.println(interfaceC.PROP_C);
  }
}
```

使用接口：

接口不能创建实例，但接口可以用于声明引用类型变量。接口主要用途：

1. 定义变量，也可用于进行强制类型转换
2. 调用接口中定义的常量
3. 被其他类实现

一个类可以实现一个或多个接口，继承使用 **extends** 关键字，实现则使用 **implements** 关键字。

类实现接口的语法格式：

```java
[修饰符] class 类名 extends 父类 implements 接口1, 接口2...
{
    类体部分
}
```

实现接口与继承父类相似，一样可以获得所实现接口里定义的常量（成员变量）、方法（包括抽象方法和默认方法）。

一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）;否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。

一个类实现某个接口时，该类将会获得接口中定义的常量（成员变量）、方法等。

补充：

```java
// System.arraycopy  源代码
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
// 代码解释：
Object src : 原数组
int srcPos : 从原数据的起始位置开始
Object dest: 目标数组
int destPos: 目标数组的开始起始位置
int length : 要copy的数组的长度
```



接口和抽象类：

* 他们都不能被实例化，他们都位于继承树的顶端，用于被其他类实现和继承
* 他们都可以包含抽象方法，实现接口和继承抽象类的普通子类都必须实现这些抽象方法
* 接口体现的是一种规范，抽象类体现的是一种模板式设计
* 接口里只能包含抽象方法和默认方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法
* 接口里不能定义静态方法；抽象类里可以定义静态方法
* 接口里只能定义静态常量，不能定义普通成员变量；抽象类都可以定义
* 接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
* 接口里不能包含初始化块；但抽象类则完全可以包含初始化块。
* 一个类最多只能有一个直接父类，包括抽象类；但一个类可以实现多个接口，通过实现多个接口可以弥补 Java 单继承的不足。





